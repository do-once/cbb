{"version":3,"file":"touch-offset.js","sourceRoot":"","sources":["../../src/libs/touch-offset.ts"],"names":[],"mappings":"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","sourcesContent":["import { ones, inv, multiply } from 'mathjs'\n\n/**\n * 模拟鼠标的offsetX(考虑了transform rotate的情况)\n * @param x 坐标x\n * @param y 坐标y\n * @param elOrCache 节点或缓存\n * @returns touch.offsetX\n */\nexport function getOffsetPosition(x: number, y: number, elOrCache: any) {\n  function getVertexPosition(el: any) {\n    let currentTarget = el\n    let top = 0\n    let left = 0\n    while (currentTarget !== null) {\n      top += currentTarget.offsetTop\n      left += currentTarget.offsetLeft\n      currentTarget = currentTarget.offsetParent\n    }\n    return { top, left }\n  }\n\n  function getTranformData(el: any) {\n    let style = window.getComputedStyle(el)\n    let transform: any = style.transform || ''\n    let transformOrigin = style.transformOrigin || ''\n\n    let origin = { x: 0, y: 0 }\n    let matrix = ones([3, 3])\n    if (transform !== 'none') {\n      let originArray = transformOrigin.split(' ')\n      origin.x = parseInt(originArray[0])\n      origin.y = parseInt(originArray[1])\n\n      let matrixString = transform.match(/\\(([^)]*)\\)/)[1]\n      let stringArray: any = matrixString.split(',')\n      let temp: any = []\n      stringArray.forEach((value: any) => {\n        temp.push(parseFloat(value.trim()))\n      })\n      temp = [\n        [temp[0], temp[2], temp[4]],\n        [temp[1], temp[3], temp[5]],\n        [0, 0, 1]\n      ]\n\n      matrix = inv(temp)\n    } else {\n      matrix = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n      ]\n    }\n    return { matrix, origin }\n  }\n\n  function computPosition(data: any) {\n    data.forEach((obj: any) => {\n      let {\n        temp,\n        origin,\n        vertex: { left, top }\n      } = obj as any\n      x = x - left - origin.x\n      y = y - top - origin.y\n      let result = multiply(temp, [x, y, 1])\n      x = result[0] + origin.x\n      y = result[1] + origin.y\n    })\n    return { x, y }\n  }\n\n  let data = []\n  if (elOrCache instanceof Node) {\n    var el = elOrCache\n    while (el !== null && el.nodeType === 1) {\n      let { left, top } = getVertexPosition(el)\n      let transformData = getTranformData(el)\n      let temp = transformData.matrix\n      let origin = transformData.origin\n\n      if (data.length > 0) {\n        data[0].vertex.left -= left\n        data[0].vertex.top -= top\n      }\n      data.unshift({\n        temp,\n        origin,\n        vertex: {\n          left,\n          top\n        }\n      })\n      el = el.parentNode as Node\n    }\n  } else if (elOrCache instanceof Array) {\n    data = elOrCache\n  }\n  let pos = computPosition(data)\n  return { x: pos.x, y: pos.y, data }\n}\n\n/**\n * 获取父节点的滚动距离\n * @param target HTMLElement 节点\n * @returns 父元素滚动距离\n */\nexport function getScroll(target: HTMLElement) {\n  let parentScrollTop = 0\n  let parentScrollLeft = 0\n\n  let curTarget = <HTMLElement>(<HTMLElement>target).parentElement\n  while (curTarget !== null) {\n    parentScrollTop += curTarget.scrollTop\n    parentScrollLeft += curTarget.scrollLeft\n\n    if (getComputedStyle(curTarget).position === 'fixed') {\n      console.log('fixed', curTarget)\n      return {\n        parentScrollTop,\n        parentScrollLeft\n      }\n    }\n\n    curTarget = <HTMLElement>curTarget.parentElement\n  }\n\n  return {\n    parentScrollTop,\n    parentScrollLeft\n  }\n}\n"]}